<template>
  <li 
    :class="nodeClasses"
    :style="nodeStyles"
    role="treeitem"
    :aria-expanded="hasChildren ? isExpanded : undefined"
    :aria-selected="isSelected && !hasChildren"
    :aria-level="level + 1"
    :data-node-key="node.key"
  >
    <!-- ËäÇÁÇπÂÜÖÂÆπ -->
    <div
      ref="contentRef"
      :class="contentClasses"
      :style="contentStyles"
      :tabindex="!hasChildren ? 0 : -1"
      @click="handleNodeClick"
      @dblclick="handleNodeDoubleClick"
      @contextmenu="handleContextMenu"
      @dragstart="handleDragStart"
      @dragend="handleDragEnd"
      @dragenter="handleDragEnter"
      @dragover="handleDragOver"
      @dragleave="handleDragLeave"
      @drop="handleDrop"
      :draggable="isDraggable"
    >
      <!-- Áº©Ëøõ -->
      <span 
        v-for="i in level" 
        :key="i" 
        class="p-tree-node-indent"
        :style="{ width: `${indent}px` }"
      ></span>

      <!-- Â±ïÂºÄ/ÊäòÂè†ÊåâÈíÆ -->
      <button
        v-if="hasChildren"
        :class="togglerClasses"
        @click.stop="handleToggle"
        type="button"
        :aria-label="isExpanded ? mergedConfig.i18n.collapse : mergedConfig.i18n.expand"
        tabindex="-1"
      >
        <svg 
          :class="togglerIconClasses"
          width="16" 
          height="16" 
          viewBox="0 0 16 16" 
          fill="currentColor"
        >
          <polygon points="6,4 6,12 10,8" />
        </svg>
      </button>
      <span v-else class="p-tree-node-toggler-spacer"></span>

      <!-- Â§çÈÄâÊ°Ü (‰ªÖÂú® checkbox Ê®°Âºè‰∏ãÊòæÁ§∫) -->
      <div
        v-if="selectionMode === 'checkbox'"
        :class="checkboxClasses"
        @click.stop="handleCheckboxClick"
      >
        <input
          type="checkbox"
          :checked="isSelected"
          :indeterminate="isPartiallySelected"
          class="p-tree-node-checkbox-input"
          tabindex="-1"
          readonly
        />
        <div class="p-tree-node-checkbox-box">
          <Check v-if="isSelected" :size="12" />
          <Minus v-else-if="isPartiallySelected" :size="12" />
        </div>
      </div>

      <!-- ËäÇÁÇπÂõæÊ†á -->
      <span v-if="nodeIcon" :class="iconClasses">
        <component 
          v-if="isIconComponent(nodeIcon)" 
          :is="nodeIcon" 
          :size="16" 
        />
        <i v-else :class="nodeIcon"></i>
      </span>

      <!-- Âä†ËΩΩÊåáÁ§∫Âô® -->
      <span v-if="node.loading" class="p-tree-node-loading">
        <Loader2 :size="16" class="animate-spin" />
      </span>

      <!-- ËäÇÁÇπÊ†áÁ≠æ -->
      <span :class="labelClasses">
        <slot name="node" :node="node" :level="level">
          {{ node.label }}
        </slot>
      </span>
    </div>

    <!-- Â≠êËäÇÁÇπ -->
    <ul
      v-if="hasChildren && isExpanded"
      :class="childrenClasses"
      role="group"
    >
      <TreeNode
        v-for="child in node.children"
        :key="child.key"
        :node="child"
        :level="level + 1"
        :indent="indent"
        :selection-mode="selectionMode"
        :is-selected="isChildSelected(child)"
        :is-partially-selected="isChildPartiallySelected(child)"
        :is-expanded="isChildExpanded(child)"
        :drag-indicator-class="getDragIndicatorClass(child)"
        :draggable-nodes="draggableNodes"
        :selected-background-color="selectedBackgroundColor"
        :selected-text-color="selectedTextColor"
        :focus-background-color="focusBackgroundColor"
        :focus-text-color="focusTextColor"
        @node-click="$emit('node-click', $event)"
        @node-double-click="$emit('node-double-click', $event)"
        @node-context-menu="$emit('node-context-menu', $event)"
        @node-toggle="$emit('node-toggle', $event)"
        @node-select="$emit('node-select', $event)"
        @node-unselect="$emit('node-unselect', $event)"
        @node-drag-start="$emit('node-drag-start', $event)"
        @node-drag-end="$emit('node-drag-end', $event)"
        @node-drop="$emit('node-drop', $event)"
      >
        <template #node="slotProps">
          <slot name="node" v-bind="slotProps" />
        </template>
      </TreeNode>
    </ul>
  </li>
</template>

<script setup lang="ts">
import { computed, inject, type Component, onMounted, ref, nextTick } from 'vue'
import { Check, Minus, Loader2 } from 'lucide-vue-next'
import type { 
  TreeNode as TreeNodeType, 
  TreeSelectionMode,
  TreeNodeSelectEvent,
  TreeNodeUnselectEvent,
  TreeNodeExpandEvent,
  TreeNodeCollapseEvent,
  TreeNodeDropEvent,
  TreeConfig
} from '../lib/types'
import { DEFAULT_TREE_CONFIG } from '../lib/types'

// Props
interface Props {
  node: TreeNodeType
  level?: number
  indent?: number
  selectionMode?: TreeSelectionMode
  isSelected?: boolean
  isPartiallySelected?: boolean
  isExpanded?: boolean
  dragIndicatorClass?: string
  draggableNodes?: boolean
  selectedBackgroundColor?: string
  selectedTextColor?: string
  focusBackgroundColor?: string
  focusTextColor?: string
  treeId?: string
  config?: TreeConfig
}

const props = withDefaults(defineProps<Props>(), {
  level: 0,
  indent: 20,
  selectionMode: 'single',
  isSelected: false,
  isPartiallySelected: false,
  isExpanded: false,
  dragIndicatorClass: '',
  draggableNodes: false,
  selectedBackgroundColor: '#e3f2fd',
  selectedTextColor: '#1565c0',
  focusBackgroundColor: '#1e40af',
  focusTextColor: 'white'
})

// Emits
interface Emits {
  'node-click': [event: { originalEvent: Event; node: TreeNodeType }]
  'node-double-click': [event: { originalEvent: Event; node: TreeNodeType }]
  'node-context-menu': [event: { originalEvent: Event; node: TreeNodeType }]
  'node-toggle': [event: TreeNodeExpandEvent | TreeNodeCollapseEvent]
  'node-select': [event: TreeNodeSelectEvent]
  'node-unselect': [event: TreeNodeUnselectEvent]
  'node-drag-start': [event: { originalEvent: DragEvent; node: TreeNodeType }]
  'node-drag-end': [event: { originalEvent: DragEvent; node: TreeNodeType }]
  'node-drop': [event: TreeNodeDropEvent]
}

const emit = defineEmits<Emits>()

// ÈÖçÁΩÆÂêàÂπ∂
const mergedConfig = computed(() => ({
  ...DEFAULT_TREE_CONFIG,
  ...props.config
}))

// Ê∑ªÂä†refÊù•ÂºïÁî®DOMÂÖÉÁ¥†
const contentRef = ref<HTMLElement | null>(null)

// ËÆ°ÁÆóÂ±ûÊÄß
const hasChildren = computed(() => {
  return props.node.children && props.node.children.length > 0
})

const isDraggable = computed(() => {
  const result = props.draggableNodes && props.node.draggable !== false
  // Ê∑ªÂä†Êõ¥ËØ¶ÁªÜÁöÑË∞ÉËØï‰ø°ÊÅØ
  console.log('üîç isDraggable computed for node:', props.node.key, {
    draggableNodes: props.draggableNodes,
    nodeDraggable: props.node.draggable,
    result: result
  })
  return result
})

const nodeIcon = computed(() => {
  if (props.node.loading) return null
  
  if (hasChildren.value) {
    return props.isExpanded 
      ? (props.node.expandedIcon || props.node.icon)
      : (props.node.collapsedIcon || props.node.icon)
  }
  
  return props.node.icon
})

// Ê†∑ÂºèÁ±ª
const nodeClasses = computed(() => [
  'p-tree-node',
  {
    'p-tree-node-leaf': !hasChildren.value,
    'p-tree-node-expanded': hasChildren.value && props.isExpanded,
    'p-tree-node-collapsed': hasChildren.value && !props.isExpanded,
    // Âè™ÊúâÂè∂Â≠êËäÇÁÇπÔºàÊñá‰ª∂ÔºâÊâçËÉΩÊòæÁ§∫ÈÄâ‰∏≠Ê†∑ÂºèÔºåÊñá‰ª∂Â§π‰∏çÊòæÁ§∫ÈÄâ‰∏≠Ê†∑Âºè
    'p-tree-node-selected': props.isSelected && !hasChildren.value,
    'p-tree-node-partial': props.isPartiallySelected && !hasChildren.value,
    'p-tree-node-loading': props.node.loading,
  },
  props.node.styleClass,
  props.dragIndicatorClass
])

const contentClasses = computed(() => [
  'p-tree-node-content',
  {
    // Âè™ÊúâÂè∂Â≠êËäÇÁÇπÔºàÊñá‰ª∂ÔºâÊâçËÉΩË¢´ÈÄâ‰∏≠ÔºåÊñá‰ª∂Â§πËäÇÁÇπ‰∏çÂ∫îËØ•ÊúâÈÄâ‰∏≠Áõ∏ÂÖ≥ÁöÑÁ±ª
    'p-tree-node-selectable': props.node.selectable !== false && !hasChildren.value,
    'p-tree-node-draggable': isDraggable.value,
    'p-tree-node-droppable': props.node.droppable !== false,
  }
])

const togglerClasses = computed(() => [
  'p-tree-node-toggler',
  {
    'p-tree-node-toggler-expanded': props.isExpanded,
    'p-tree-node-toggler-collapsed': !props.isExpanded,
  }
])

const togglerIconClasses = computed(() => [
  'p-tree-node-toggler-icon',
  {
    'p-tree-node-toggler-icon-expanded': props.isExpanded,
    'p-tree-node-toggler-icon-collapsed': !props.isExpanded,
  }
])

const checkboxClasses = computed(() => [
  'p-tree-node-checkbox',
  {
    'p-tree-node-checkbox-checked': props.isSelected,
    'p-tree-node-checkbox-partial': props.isPartiallySelected,
  }
])

const iconClasses = computed(() => [
  'p-tree-node-icon',
  {
    'p-tree-node-icon-expanded': hasChildren.value && props.isExpanded,
    'p-tree-node-icon-collapsed': hasChildren.value && !props.isExpanded,
    'p-tree-node-icon-leaf': !hasChildren.value,
  }
])

const labelClasses = computed(() => [
  'p-tree-node-label',
  {
    // Âè™ÊúâÂè∂Â≠êËäÇÁÇπÔºàÊñá‰ª∂ÔºâÊâçËÉΩÊòæÁ§∫ÈÄâ‰∏≠Ê†∑ÂºèÔºåÊñá‰ª∂Â§π‰∏çÊòæÁ§∫ÈÄâ‰∏≠Ê†∑Âºè
    'p-tree-node-label-selected': props.isSelected && !hasChildren.value,
  }
])

const childrenClasses = computed(() => [
  'p-tree-node-children'
])

// Ê†∑Âºè
const nodeStyles = computed(() => ({
  ...props.node.style
}))

const contentStyles = computed(() => {
  const styles: Record<string, any> = {
    paddingLeft: `${props.level * props.indent}px`
  }
  
  // ËÆæÁΩÆCSSÂèòÈáèÔºåÁî®‰∫éCSSÊñá‰ª∂‰∏≠ÁöÑÊ†∑Âºè
  const focusBackgroundColor = props.focusBackgroundColor || mergedConfig.value.style.focusBackgroundColor
  const focusTextColor = props.focusTextColor || mergedConfig.value.style.focusTextColor
  
  if (focusBackgroundColor) {
    styles['--p-tree-focus-background'] = focusBackgroundColor
  }
  if (focusTextColor) {
    styles['--p-tree-focus-color'] = focusTextColor
  }
  
  // Âè™ÊúâÂè∂Â≠êËäÇÁÇπÊâçÂ∫îÁî®ÈÄâ‰∏≠Ê†∑Âºè
  if (!hasChildren.value && props.isSelected) {
    // ÈÄâ‰∏≠Ê†∑Âºè
    const selectedBackgroundColor = props.selectedBackgroundColor || mergedConfig.value.style.selectedBackgroundColor
    const selectedTextColor = props.selectedTextColor || mergedConfig.value.style.selectedTextColor
    
    if (selectedBackgroundColor) {
      styles.backgroundColor = selectedBackgroundColor
    }
    if (selectedTextColor) {
      styles.color = selectedTextColor
    }
  }
  
  return styles
})

// ‰∫ã‰ª∂Â§ÑÁêÜ
const handleNodeClick = (event: MouseEvent) => {
  try {
    if (props.node.selectable === false) return
    
    emit('node-click', { originalEvent: event, node: props.node })
    
    // Ê£ÄÊü•ÊòØÂê¶‰∏∫Êñá‰ª∂Â§πËäÇÁÇπÔºàÊúâchildrenÁöÑËäÇÁÇπÔºâ
    const isFolder = hasChildren.value
    
    if (isFolder) {
      // Êñá‰ª∂Â§πËäÇÁÇπÂè™Ëß¶ÂèëÂ±ïÂºÄ/ÊäòÂè†Ôºå‰∏çËß¶ÂèëÈÄâ‰∏≠
      handleToggle(event)
      return
    }
    
    // Âè™ÊúâÂè∂Â≠êËäÇÁÇπÔºàÊñá‰ª∂ÔºâÊâçËÉΩË¢´ÈÄâ‰∏≠
    // Ëá™Âä®ÈÄâÊã©ÈÄªËæë
    if (props.selectionMode === 'single') {
      if (!props.isSelected) {
        emit('node-select', { originalEvent: event, node: props.node })
      }
    } else if (props.selectionMode === 'multiple') {
      if (event.ctrlKey || event.metaKey) {
        if (props.isSelected) {
          emit('node-unselect', { originalEvent: event, node: props.node })
        } else {
          emit('node-select', { originalEvent: event, node: props.node })
        }
      } else {
        emit('node-select', { originalEvent: event, node: props.node })
      }
    }
  } catch (error) {
    console.error('TreeNode click error:', error)
  }
}

const handleNodeDoubleClick = (event: Event) => {
  emit('node-double-click', { originalEvent: event, node: props.node })
  
  // ÂèåÂáªÂ±ïÂºÄ/ÊäòÂè†
  if (hasChildren.value) {
    handleToggle(event)
  }
}

const handleContextMenu = (event: Event) => {
  emit('node-context-menu', { originalEvent: event, node: props.node })
}

const handleToggle = (event: Event) => {
  if (!hasChildren.value) return
  
  if (props.isExpanded) {
    emit('node-toggle', {
      originalEvent: event,
      node: props.node
    } as TreeNodeCollapseEvent)
  } else {
    emit('node-toggle', {
      originalEvent: event,
      node: props.node
    } as TreeNodeExpandEvent)
  }
}

const handleCheckboxClick = (event: Event) => {
  if (props.selectionMode !== 'checkbox') return
  
  if (props.isSelected) {
    emit('node-unselect', { originalEvent: event, node: props.node })
  } else {
    emit('node-select', { originalEvent: event, node: props.node })
  }
}

// ÊãñÊãΩ‰∫ã‰ª∂
const handleDragStart = (event: DragEvent) => {
  console.log('üöÄüöÄüöÄ TreeNode handleDragStart called:', props.node.key, props.node.label)
  console.log('üöÄ isDraggable:', isDraggable.value)
  console.log('üöÄ props.draggableNodes:', props.draggableNodes)
  console.log('üöÄ props.node.draggable:', props.node.draggable)
  console.log('üöÄ event.target:', event.target)
  console.log('üöÄ event.target draggable attribute:', (event.target as HTMLElement)?.getAttribute('draggable'))
  console.log('üöÄ contentRef.value:', contentRef.value)
  console.log('üöÄ contentRef.value draggable:', contentRef.value?.getAttribute('draggable'))
  console.log('üöÄ tree object:', tree)
  console.log('üöÄ tree.onDragStart available:', !!tree.onDragStart)
  console.log('üöÄ event:', event)
  
  if (!isDraggable.value) {
    console.log('‚ùå Node is not draggable, preventing default')
    event.preventDefault()
    return
  }
  
  // Ë∞ÉÁî®Áà∂ÁªÑ‰ª∂ÁöÑÊãñÊãΩÂºÄÂßãÊñπÊ≥ï
  if (tree.onDragStart) {
    console.log('‚úÖ Calling tree.onDragStart')
    tree.onDragStart(event, props.node)
  } else {
    console.log('‚ùå tree.onDragStart is not available')
  }
  
  // ÂèëÂá∫ÊãñÊãΩÂºÄÂßã‰∫ã‰ª∂
  emit('node-drag-start', { originalEvent: event, node: props.node })
}

const handleDragEnd = (event: DragEvent) => {
  // Ë∞ÉÁî®Áà∂ÁªÑ‰ª∂ÁöÑÊãñÊãΩÁªìÊùüÊñπÊ≥ï
  if (tree.onDragEnd) {
    tree.onDragEnd(event)
  }
  
  emit('node-drag-end', { originalEvent: event, node: props.node })
}

const handleDragEnter = (event: DragEvent) => {
  event.preventDefault()
  
  // Ë∞ÉÁî®Áà∂ÁªÑ‰ª∂ÁöÑÊãñÊãΩËøõÂÖ•ÊñπÊ≥ï
  if (tree.onDragEnter) {
    tree.onDragEnter(event, props.node)
  }
}

const handleDragOver = (event: DragEvent) => {
  console.log('üî• DRAG OVER:', props.node.label)
  event.preventDefault()
  tree.onDragOver(event, props.node, props.treeId || '')
}

const handleDragLeave = (event: DragEvent) => {
  console.log('üî• DRAG LEAVE:', props.node.label)
  tree.onDragLeave(event)
}

const handleDrop = (event: DragEvent) => {
  event.preventDefault()
  
  console.log('üéØ TreeNode handleDrop:', props.node.label)
  
  // Ë∞ÉÁî®Áà∂ÁªÑ‰ª∂ÁöÑÊãñÊãΩÊîæÁΩÆÊñπÊ≥ï
  let dropEvent: TreeNodeDropEvent | null = null
  if (tree.onDrop) {
    dropEvent = tree.onDrop(event, props.node)
    console.log('üì¶ ‰ªé tree.onDrop Ëé∑Âæó‰∫ã‰ª∂:', dropEvent)
  }
  
  // ÂØπ‰∫éË∑®Ê†ëÊãñÊãΩÔºåÂç≥‰Ωø tree.onDrop ËøîÂõû nullÔºå‰πüË¶ÅËß¶Âèë node-drop ‰∫ã‰ª∂
  // ËÆ© Tree ÁªÑ‰ª∂Êù•Â§ÑÁêÜË∑®Ê†ëÊãñÊãΩÈÄªËæë
  if (!dropEvent) {
    console.log('‚ö†Ô∏è tree.onDrop ËøîÂõû nullÔºåÂèØËÉΩÊòØË∑®Ê†ëÊãñÊãΩÔºå‰ªçÁÑ∂Ëß¶Âèë node-drop ‰∫ã‰ª∂')
    // ÂàõÂª∫‰∏Ä‰∏™Âü∫Á°ÄÁöÑ dropEvent ÂØπË±°ÔºåËÆ© Tree ÁªÑ‰ª∂Â§ÑÁêÜ
    dropEvent = {
      originalEvent: event,
      dragNode: null as any, // Â∞ÜÂú® Tree ÁªÑ‰ª∂‰∏≠ËÆæÁΩÆ
      dropNode: props.node,
      dropIndex: 0,
      dropPosition: 'inside',
      sourceTreeId: undefined,
      targetTreeId: undefined,
      isCrossTree: false,
      accept: () => {},
      reject: () => {}
    }
  }
  
  // Â¶ÇÊûú‰ªçÁÑ∂Ê≤°ÊúâÊúâÊïàÁöÑ‰∫ã‰ª∂ÂØπË±°ÔºåÊâçË∑≥Ëøá
  if (!dropEvent) {
    console.log('‚ùå Êó†Ê≥ïÂàõÂª∫ÊãñÊãΩ‰∫ã‰ª∂ÂØπË±°ÔºåË∑≥Ëøá node-drop Ëß¶Âèë')
    return
  }
  
  console.log('‚úÖ Ëß¶Âèë node-drop ‰∫ã‰ª∂:', dropEvent)
  emit('node-drop', dropEvent)
}

// ‰ªéÁà∂ÁªÑ‰ª∂Ê≥®ÂÖ•Áä∂ÊÄÅÊ£ÄÊü•ÂáΩÊï∞
interface TreeContext {
  isNodeSelected: (node: TreeNodeType) => boolean;
  isNodePartiallySelected: (node: TreeNodeType) => boolean;
  isNodeExpanded: (node: TreeNodeType) => boolean;
  getDragIndicatorClass: (node: TreeNodeType) => string;
  onDragStart?: (event: DragEvent, node: TreeNodeType) => void;
  onDragEnd?: (event: DragEvent) => void;
  onDragEnter?: (event: DragEvent, node: TreeNodeType) => void;
  onDragOver?: (event: DragEvent, node: TreeNodeType, treeId: string) => void;
  onDragLeave?: (event: DragEvent) => void;
  onDrop?: (event: DragEvent, node: TreeNodeType) => TreeNodeDropEvent | null;
}

const tree = inject<TreeContext>('tree', {
  isNodeSelected: () => false,
  isNodePartiallySelected: () => false,
  isNodeExpanded: () => false,
  getDragIndicatorClass: () => ''
})

// Â≠êËäÇÁÇπÁä∂ÊÄÅÊ£ÄÊü•
const isChildSelected = (child: TreeNodeType) => {
  return tree.isNodeSelected(child)
}

const isChildPartiallySelected = (child: TreeNodeType) => {
  return tree.isNodePartiallySelected(child)
}

const isChildExpanded = (child: TreeNodeType) => {
  return tree.isNodeExpanded(child)
}

const getDragIndicatorClass = (child: TreeNodeType) => {
  return tree.getDragIndicatorClass(child)
}

// Â∑•ÂÖ∑ÂáΩÊï∞
const isIconComponent = (icon: any): icon is Component => {
  return typeof icon === 'object' || typeof icon === 'function'
}

// Ë∞ÉËØïÔºöÊ£ÄÊü•Ë∑®Ê†ëËäÇÁÇπÁöÑ DOM ÂÖÉÁ¥†
onMounted(() => {
  console.log('üîß TreeNode mounted:', props.node.label)
  console.log('üîß Adding direct event listeners to:', props.node.label)
  
  // ‰ΩøÁî® nextTick Á°Æ‰øù DOM Â∑≤ÁªèÂÆåÂÖ®Ê∏≤Êüì
  nextTick(() => {
    console.log('üîß contentRef.value:', contentRef.value)
    console.log('üîß contentRef.value type:', typeof contentRef.value)
    
    if (contentRef.value) {
      console.log('üîß contentRef.value is valid, adding event listeners')
      console.log('üîß contentRef.value tagName:', contentRef.value.tagName)
      console.log('üîß contentRef.value classList:', contentRef.value.classList.toString())
      
      // Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂ÊµãËØï
      contentRef.value.addEventListener('click', (e) => {
        console.log('üéØ Click event triggered on:', props.node.label)
      })
      
      // Ê∑ªÂä†Èº†Ê†áÊåâ‰∏ã‰∫ã‰ª∂ÊµãËØï
      contentRef.value.addEventListener('mousedown', (e) => {
        console.log('üéØ Mousedown event triggered on:', props.node.label)
      })
      
      // Ê∑ªÂä†ÊãñÊãΩÂºÄÂßã‰∫ã‰ª∂ÊµãËØï
      contentRef.value.addEventListener('dragstart', (e) => {
        console.log('üéØ Direct dragstart event triggered on:', props.node.label)
      })
    } else {
      console.log('üîß contentRef.value is null or undefined')
    }
  })

  // ÂéüÊúâÁöÑË∑®Ê†ëËäÇÁÇπË∞ÉËØïÈÄªËæë
  if (props.node.key.toString().startsWith('tree1-') || props.node.key.toString().startsWith('tree2-')) {
    console.log(`üîç Cross-tree node: ${props.node.key} ${props.node.label} | isDraggable: ${isDraggable.value} | draggableNodes: ${props.draggableNodes} | node.draggable: ${props.node.draggable}`)
    
    // Ëé∑ÂèñËäÇÁÇπÁöÑ DOM ÂÖÉÁ¥†
    setTimeout(() => {
      const nodeElement = document.querySelector(`[data-node-key="${props.node.key}"]`)
      if (nodeElement) {
        const contentElement = nodeElement.querySelector('.p-tree-node-content')
        console.log(`üîç DOM element for ${props.node.key}:`, {
          nodeElement,
          contentElement,
          draggable: contentElement?.getAttribute('draggable'),
          hasContentElement: !!contentElement
        })
      } else {
        console.log(`‚ùå No DOM element found for ${props.node.key}`)
      }
    }, 500)
  }
})
</script>

<style scoped>
/* ÁßªÈô§ÊâÄÊúâTailwindÁ±ªÔºå‰ΩøÁî®tree.css‰∏≠ÁöÑÂÖ®Â±ÄÊ†∑Âºè */
/* Ëøô‰∫õÊ†∑ÂºèÁé∞Âú®Áî±tree.cssÂíå‰∏ªÈ¢òÁ≥ªÁªüÁªü‰∏ÄÁÆ°ÁêÜ */

/* Âè™‰øùÁïôÁªÑ‰ª∂ÁâπÂÆöÁöÑÊ†∑ÂºèË¶ÜÁõñ */
.p-tree-node-content {
  /* Á°Æ‰øùÂÜÖËÅîÊ†∑Âºè‰ºòÂÖàÁ∫ß */
}

.p-tree-node-content[style*="background-color"] {
  /* ÂÜÖËÅîÊ†∑Âºè‰ºöËá™Âä®Ë¶ÜÁõñÂÖ®Â±ÄÊ†∑Âºè */
}

.p-tree-node-content[style*="color"] {
  /* ÂÜÖËÅîÊ†∑Âºè‰ºöËá™Âä®Ë¶ÜÁõñÂÖ®Â±ÄÊ†∑Âºè */
}

/* ÁÑ¶ÁÇπÁä∂ÊÄÅÊ†∑ÂºèÈáçÁΩÆ - Á°Æ‰øù‰∏éÂÖ®Â±ÄÊ†∑Âºè‰∏ÄËá¥ */
.p-tree-node-focused .p-tree-node-content {
  outline: none !important;
  border: none !important;
  box-shadow: none !important;
}

/* ÈÄâ‰∏≠‰∏îÁÑ¶ÁÇπÁä∂ÊÄÅ - Á°Æ‰øù‰∏éÂÖ®Â±ÄÊ†∑Âºè‰∏ÄËá¥ */
.p-tree-node-selected.p-tree-node-focused .p-tree-node-content {
  outline: none !important;
  border: none !important;
  box-shadow: none !important;
}
</style>